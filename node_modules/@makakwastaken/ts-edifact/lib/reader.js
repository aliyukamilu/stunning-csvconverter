"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Reader = void 0;
const cache_1 = require("./cache");
const configuration_1 = require("./configuration");
const parser_1 = require("./parser");
const segments_1 = require("./segments");
const util_1 = require("./util");
const validator_1 = require("./validator");
class Reader {
    result;
    elements;
    element;
    validator;
    parser;
    defined = false;
    validationTables = [];
    definitionCache = new cache_1.Cache(15);
    unbCharsetDefined = false;
    separators;
    constructor(messageSpecDir, throwOnMissingDefinitions = false) {
        const config = new configuration_1.Configuration({
            validator: new validator_1.ValidatorImpl(throwOnMissingDefinitions),
        });
        this.parser = new parser_1.Parser(config);
        this.validator = config.validator;
        this.result = [];
        this.elements = [];
        let components = [];
        let componentIndex = 0;
        let activeSegment;
        this.parser.onOpenSegment = (segment, segmentEntry) => {
            this.elements = [];
            this.element = undefined;
            activeSegment = segmentEntry
                ? { id: segment, segmentEntry: segmentEntry }
                : null;
        };
        this.parser.onElement = (newElement) => {
            if (this.element) {
                this.elements.push({ ...this.element, components });
            }
            this.element = newElement;
            components = [];
            componentIndex = 0;
        };
        this.parser.onComponent = (value) => {
            if (activeSegment?.id === 'UNB' && !this.unbCharsetDefined) {
                this.parser.updateCharset(value);
                this.unbCharsetDefined = true;
            }
            if (this.element) {
                const component = this.element.components[componentIndex];
                components.push({ ...component, value });
                componentIndex++;
            }
        };
        this.parser.onCloseSegment = () => {
            if ((0, util_1.isDefined)(activeSegment)) {
                if (this.element) {
                    this.elements.push({ ...this.element, components });
                }
                if (activeSegment.id === 'UNH') {
                    const messageIdentifier = (0, util_1.findElement)(this.elements, 'S009').components;
                    const messageType = messageIdentifier[0].value;
                    const messageVersion = messageIdentifier[1].value;
                    const messageRelease = messageIdentifier[2].value;
                    const key = messageVersion + messageRelease + '_' + messageType;
                    if (this.definitionCache.contains(key)) {
                        const segmentTable = this.definitionCache.get(key);
                        this.validator.define(segmentTable);
                    }
                    else {
                        let segmentTableBuilder = new segments_1.SegmentTableBuilder(messageType);
                        const version = (messageVersion + messageRelease).toUpperCase();
                        segmentTableBuilder = segmentTableBuilder.forVersion(version);
                        if (messageSpecDir) {
                            segmentTableBuilder =
                                segmentTableBuilder.specLocation(messageSpecDir);
                        }
                        else {
                            segmentTableBuilder = segmentTableBuilder.specLocation('./');
                        }
                        const segmentTable = segmentTableBuilder.build();
                        this.validator.define(segmentTable);
                        this.definitionCache.insert(key, segmentTable);
                    }
                }
                this.result.push({
                    name: activeSegment.id,
                    elements: this.elements,
                });
                activeSegment = null;
            }
        };
        this.separators = this.parser.separators();
    }
    define(definitions) {
        this.validator.define(definitions);
    }
    initializeIfNeeded() {
        if (!this.defined) {
            if (this.validationTables.length > 0) {
                for (const table of this.validationTables) {
                    this.validator.define(table);
                }
            }
            else {
                this.validator.define(segments_1.SegmentTableBuilder.enrichWithDefaultSegments(new validator_1.Dictionary()));
            }
            this.defined = true;
        }
    }
    parse(document) {
        this.initializeIfNeeded();
        this.result = [];
        this.parser.write(document);
        this.parser.end();
        this.separators = this.parser.separators();
        return this.result;
    }
}
exports.Reader = Reader;
//# sourceMappingURL=reader.js.map