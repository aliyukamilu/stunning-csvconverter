"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tracker = exports.Pointer = void 0;
class Pointer {
    array;
    position;
    count;
    constructor(array, position) {
        this.array = array;
        this.position = position || 0;
        this.count = 0;
    }
    content() {
        return this.array[this.position].content;
    }
    mandatory() {
        return this.array[this.position].mandatory;
    }
    repetition() {
        return this.array[this.position].repetition;
    }
    name() {
        return this.array[this.position].name;
    }
    section() {
        if (this.array[this.position] && this.array[this.position].section) {
            return this.array[this.position].section;
        }
        return undefined;
    }
}
exports.Pointer = Pointer;
class Tracker {
    stack;
    constructor(table) {
        this.stack = [new Pointer(table, 0)];
    }
    reset() {
        this.stack.length = 1;
        this.stack[0].position = 0;
        this.stack[0].count = 0;
    }
    accept(segment) {
        let current = this.stack[this.stack.length - 1];
        let optionals = [];
        let probe = 0;
        while (segment !== current?.content() ||
            current.count === current.repetition()) {
            if (Array.isArray(current?.content()) &&
                current.count < current.repetition()) {
                probe++;
                if (!current.mandatory()) {
                    optionals.push(this.stack.length);
                }
                current.count++;
                current = new Pointer(current?.content(), 0);
                this.stack.push(current);
            }
            else {
                if (current.mandatory() && current.count === 0) {
                    if (optionals.length === 0) {
                        throw new Error(`A mandatory segment ${current?.content()} is missing`);
                    }
                    else {
                        probe = probe - this.stack.length;
                        this.stack.length = optionals.pop();
                        current = this.stack[this.stack.length - 1];
                        probe = probe + this.stack.length;
                    }
                }
                current.position++;
                current.count = 0;
                if (current.position === current.array.length) {
                    this.stack.pop();
                    current = this.stack[this.stack.length - 1];
                    if (this.stack.length === 0) {
                        throw new Error('Reached the end of the segment table');
                    }
                    if (probe === 0 && current.count < current.repetition()) {
                        probe++;
                        optionals = [this.stack.length];
                        current.count++;
                        current = new Pointer(current?.content(), 0);
                        this.stack.push(current);
                    }
                    else {
                        if (!current.mandatory() || current.count > 1) {
                            optionals.pop();
                        }
                        probe = probe > 0 ? probe - 1 : 0;
                        current.count = current.repetition();
                    }
                }
            }
        }
        current.count += 1;
        return;
    }
}
exports.Tracker = Tracker;
//# sourceMappingURL=tracker.js.map