"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findElement = exports.storeAllDefaultSpecs = exports.formatComponents = exports.persist = exports.isDefined = void 0;
const fs = __importStar(require("fs"));
const messageStructureParser_1 = require("./edi/messageStructureParser");
function isDefined(value) {
    return value !== undefined && value !== null;
}
exports.isDefined = isDefined;
function toString(data, pretty) {
    if (pretty) {
        return JSON.stringify(data, null, 2);
    }
    else {
        return JSON.stringify(data);
    }
}
function persist(data, path, pretty, defaultVersion = false) {
    const messageStructDef = toString(data.messageStructureDefinition, pretty);
    const messageStructDefFileName = (defaultVersion ? '' : data.version + data.release + '_') +
        data.messageType +
        '.struct.json';
    const segments = toString(data.segmentTable.entries);
    const segmentsFileName = (defaultVersion ? '' : data.version + data.release + '_') +
        data.messageType +
        '.segments.json';
    let p = path;
    if (!p.endsWith('/')) {
        p += '/';
    }
    fs.writeFileSync(p + messageStructDefFileName, messageStructDef);
    fs.writeFileSync(p + segmentsFileName, segments);
}
exports.persist = persist;
const formatComponents = (elements, segmentId, decimalSeparator) => {
    const result = {};
    result['tag'] = segmentId;
    elements.forEach((element) => {
        element.components.forEach((component) => {
            if (component.value) {
                if (element.components.length <= 1) {
                    result[element.name] = component.value;
                    return;
                }
                else {
                    if (!result[element.name]) {
                        result[element.name] = {};
                    }
                    if (typeof result[element.name] === 'object') {
                        if (decimalSeparator) {
                            result[element.name][component.name] = component.value.replace(decimalSeparator, '.');
                        }
                        else {
                            result[element.name][component.name] = component.value;
                        }
                    }
                }
            }
        });
    });
    return Object(result);
};
exports.formatComponents = formatComponents;
function storeAllDefaultSpecs(version, location) {
    const types = [
        'APERAK',
        'INVOIC',
        'AUTHOR',
        'BALANC',
        'DESADV',
        'GENRAL',
        'IFTMIN',
        'INVOIC',
        'INVRPT',
        'ORDERS',
        'OSTENQ',
        'OSTRPT',
        'PARTIN',
        'TAXCON',
        'VATDEC',
    ];
    for (const typeName of types) {
        const structParser = new messageStructureParser_1.UNECEMessageStructureParser(version, typeName);
        structParser
            .loadTypeSpec()
            .then((result) => {
            persist(result, location, false, true);
        })
            .then(() => {
            console.log(`Stored definition for type ${typeName} of version ${version} at location ${location}`);
        })
            .catch((error) => {
            console.warn(`Could not load Message structure and segment/element definitions for message type ${typeName} of version ${version}. Reason: ${error.message}`);
        });
    }
}
exports.storeAllDefaultSpecs = storeAllDefaultSpecs;
const findElement = (elements, id) => {
    const element = elements?.find((elementEntry) => elementEntry.id === id);
    return element;
};
exports.findElement = findElement;
//# sourceMappingURL=util.js.map